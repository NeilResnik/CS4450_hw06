Game Name -> channel
    socket.channel("game:<game name>", {user: <user as string>})




SOCKET MESSAGES:
"joinGame", {game: gamename, user: name} -> user types in game name, either creates new game or joins running game
                                        -> if user exists in game, become that user?
                                        -> if game is "playing", no menu for choosing observer or player, automatically an observer
"modifyUser", {user: name, player: boolean} -> call to change a user player | observer
                                            -> call to set player to ready or unready
"readyUp", {user: name, ready: boolean} -> call to toggle if a player is ready (toggle only visible if user is a player?)
"guess", guess ->  called when a user guesses





Lobby:
    3 States: Ready, Not Ready, Observe - all are sent to server when changed, starts in not ready
Game:
    Guess send format: 
        List of Strings (each string = 1 letter)

    view:
    {
        Users: List of Strings,
        Observers: List of Strings,
        Guesses: List of (Maps of 
            {
                User: string,
                Guess: string,
                Bulls: number,
                Cows: number
            }), each map = round, front/lower index = more recent
    }

    view2 {
        players:
        [
            'name': [{
                guess: string,
                bulls: number,
                cows: number
            }],
            'ready': boolean
        ],

        gameState: "waiting" || "playing"
    }


    GAME STATES: "waiting", "playing"
     - server tells the clients if they should display the lobby or the game

    Timer: Seperate instances on each side, client resets timer when state is received
    (use broadcast serverside)





Internal Server state (game.ex):

{
    players: [{
        'name': [{
                guess: string,
                bulls: number,
                cows: number
            }]
        ],
        'ready': boolean

    }]
    observers: ['name', 'name', 'name' ...]
    gameState: "waiting" || "playing"
    answer: ["#", "#", "#", "#"]
    gameName: name
}