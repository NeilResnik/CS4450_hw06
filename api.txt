
Game Name -> channel
    socket.channel("game:<game name>", {user: <user as string>})

Lobby:
    3 States: Ready, Not Ready, Observe - all are sent to server when changed, starts in not ready
Game:
    Guess send format: 
        List of Strings (each string = 1 letter)

    view:
    {
        Users: List of Strings,
        Observers: List of Strings,
        Guesses: List of (Maps of 
            {
                User: string,
                Guess: string,
                Bulls: number,
                Cows: number
            }), each map = round, front/lower index = more recent
    }

    view2 {
        users:
        [
            'name': [{
                guess: string,
                bulls: number,
                cows: number
            }]
        ],

        gameState: "waiting" || "playing"
    }


    GAME STATES: "waiting", "playing"
     - server tells the clients if they should display the lobby or the game

    Timer: Seperate instances on each side, client resets timer when state is received
    (use broadcast serverside)





Internal Server state (game.ex):

{
    users: [{
        'name': [{
                guess: string,
                bulls: number,
                cows: number
            }]
        ],

    }]
    gameState: "waiting" || "playing"
    answer: ["#", "#", "#", "#"]
    gameName: name
}
